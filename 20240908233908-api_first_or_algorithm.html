<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>api first, or algorithm?</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c5198630dc662cd9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c5198630dc662cd9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-00e108e884e8ba17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5e7e1e817aab6e29.js" defer=""></script><script src="/_next/static/chunks/929-fd697a5772151b77.js" defer=""></script><script src="/_next/static/chunks/329-4859dea2fee324e7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-36a5cddfb88d7ae3.js" defer=""></script><script src="/_next/static/gozuaWB0mxG4TSZJqOmLO/_buildManifest.js" defer=""></script><script src="/_next/static/gozuaWB0mxG4TSZJqOmLO/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>api first, or algorithm?</h1><p>Interesting conversation had with Sid today, while we were bashing out the algorithm for <a href="/20240905120229-toricelli">Toricelli</a>: he tends to begin by creating a &quot;vertically complete&quot; thing he can tinker with, and I tend to begin by creating the &quot;engine&quot; - the &quot;thing that works&quot;, even if it doesn&#x27;t hook up to anything yet.
</p><p>But on balance, I think the API is often the marginally useful thing to <em>other people</em> - the thing that ooks everything up is modular, because the engine can be switched out for anything with the same type signature. Radically different tools can be built witht he same schema, and the schema invites imagination in a way the algorithm often doesn&#x27;t. Is this generally true? It&#x27;s certainly true for Toricelli, and for SuperMemo and other SRS tools, and for my <a href="/20230816114251-how_does_the_notebook_work">notebook</a> more generally: any number of ranking/queuing/ordering philosophies can be plugged into the general idea. Conversely, it&#x27;s far more likely that folks will have opinions and particularities around the setting for the implementation than it will be that they care whether the ranking system I use for myself will work for them at first blush. I think something like this effect is what contributes to so much of extant code being ways to control how various pieces talk to each other, as opposed to what they are saying. Code is mostly a guess at what part of a process or task can be systematized, and the pipeline is a sexy place to start.
A related phenonmenon: API-ish code is something LLMs make good guesses at. It&#x27;s the easy stuff, the boilerplate.
This could be nonsense. But it&#x27;s a fun thing to track.
Related: <a href="/20220715011054-poetry_of_structuralism">poetry of structuralism</a></p></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"api first, or algorithm?","hast":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Interesting conversation had with Sid today, while we were bashing out the algorithm for "},{"type":"element","tagName":"a","properties":{"href":"/20240905120229-toricelli"},"children":[{"type":"text","value":"Toricelli"}]},{"type":"text","value":": he tends to begin by creating a \"vertically complete\" thing he can tinker with, and I tend to begin by creating the \"engine\" - the \"thing that works\", even if it doesn't hook up to anything yet.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"But on balance, I think the API is often the marginally useful thing to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"other people"}]},{"type":"text","value":" - the thing that ooks everything up is modular, because the engine can be switched out for anything with the same type signature. Radically different tools can be built witht he same schema, and the schema invites imagination in a way the algorithm often doesn't. Is this generally true? It's certainly true for Toricelli, and for SuperMemo and other SRS tools, and for my "},{"type":"element","tagName":"a","properties":{"href":"/20230816114251-how_does_the_notebook_work"},"children":[{"type":"text","value":"notebook"}]},{"type":"text","value":" more generally: any number of ranking/queuing/ordering philosophies can be plugged into the general idea. Conversely, it's far more likely that folks will have opinions and particularities around the setting for the implementation than it will be that they care whether the ranking system I use for myself will work for them at first blush. I think something like this effect is what contributes to so much of extant code being ways to control how various pieces talk to each other, as opposed to what they are saying. Code is mostly a guess at what part of a process or task can be systematized, and the pipeline is a sexy place to start.\nA related phenonmenon: API-ish code is something LLMs make good guesses at. It's the easy stuff, the boilerplate.\nThis could be nonsense. But it's a fun thing to track.\nRelated: "},{"type":"element","tagName":"a","properties":{"href":"/20220715011054-poetry_of_structuralism"},"children":[{"type":"text","value":"poetry of structuralism"}]}]}]},"filetags":{},"backlinks":[]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20240908233908-api_first_or_algorithm"]},"buildId":"gozuaWB0mxG4TSZJqOmLO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>