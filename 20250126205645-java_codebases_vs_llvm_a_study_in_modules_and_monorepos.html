<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Java codebases vs LLVM - a study in modules and monorepos</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c5198630dc662cd9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c5198630dc662cd9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-00e108e884e8ba17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5e7e1e817aab6e29.js" defer=""></script><script src="/_next/static/chunks/929-fd697a5772151b77.js" defer=""></script><script src="/_next/static/chunks/329-4859dea2fee324e7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-36a5cddfb88d7ae3.js" defer=""></script><script src="/_next/static/2M9sssCZQEkAkbm06CBb5/_buildManifest.js" defer=""></script><script src="/_next/static/2M9sssCZQEkAkbm06CBb5/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>Java codebases vs LLVM - a study in modules and monorepos</h1><h1 id="java-codebases-vs-llvm---a-study-in-modules-and-monorepos">Java codebases vs LLVM - a study in modules and monorepos</h1><p>The Java language is best used, according to its own philosophy, to write code as self-contained, with lots of internal dependencies, and well-defined predetermined interfaces to other code. Several consequences arise in long-lived codebases as a result of this.
</p><ul><li><p>interfaces fossilize; it quickly becomes verboten to change how classes relate to other classes, because the dependency structure becomes too convoluted to disentangle or diff.
</p><ul><li><p>I say <em>becomes</em> because here the black box becomes hard to describe; what is actually happening is that a single agent with sufficiently large memory would not have issues, but a set of interacting bounded agents trying to minimise their rewriting/maintenance effort will inevitably make decisions to preserve and propagate suboptimal structures in the codebase because the dependency tree of the structure in question is too large.
</p></li><li><p>my contention is that java &quot;standards&quot;, by which I mean logical structures the changing of which would propagate to a lot of dependencies, tend to be shaped like interfaces.
</p><ul><li><p>also that this leads to specific absurdities in trying to attach any single task to the larger semantics of a codebase.
</p></li><li><p>concrete examples will follow if it seems worth pursuing in depth; I have anecdotes and one-off examples.
</p></li></ul></li></ul></li><li><p>inconsistencies arise because portions of the dependency tree are to be considered opaque wrt to their <em>functionality</em>, even though they are transparent <em>structurally</em>. The distinction breaks down in situations where, for eg.:
</p><ul><li><p>Class A has methods x and y where x and y are redundant
</p></li><li><p>Class B, inheriting A, notices this, and overrides A.x to call A.y (i.e. B.A.x -&gt; B.A.y, and B.A.y = A.y)
</p></li><li><p>A is later rewritten to omit A.y; to deprecate A.y, it now calls A.x (i.e A.y -&gt; A.x)
</p><ul><li><p>this means B.A.y -&gt; B.A.x
</p></li></ul></li></ul></li></ul><h2 id="the-package-idiom-of-software-also-has-this-problem-in-a-more-general-sense">The &quot;package&quot; idiom of software also has this problem in a more general sense</h2><p>Here there is a <a href="https://en.wikipedia.org/wiki/Dependency_hell#Problems">much more robust body</a> of examples. <a href="https://nixos.wiki/wiki/Nix_Ecosystem">NixOS</a> and the nix package manager were expressly written in order to address this specific set of issues.
</p><section><h2>Backlinks</h2><ul><li><a href="/all_pages">All Pages</a></li><li><a href="/examples">Potential Real-world examples of rule dynamics</a></li></ul></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Java codebases vs LLVM - a study in modules and monorepos","hast":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{"id":"java-codebases-vs-llvm---a-study-in-modules-and-monorepos"},"children":[{"type":"text","value":"Java codebases vs LLVM - a study in modules and monorepos"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Java language is best used, according to its own philosophy, to write code as self-contained, with lots of internal dependencies, and well-defined predetermined interfaces to other code. Several consequences arise in long-lived codebases as a result of this.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"interfaces fossilize; it quickly becomes verboten to change how classes relate to other classes, because the dependency structure becomes too convoluted to disentangle or diff.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I say "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"becomes"}]},{"type":"text","value":" because here the black box becomes hard to describe; what is actually happening is that a single agent with sufficiently large memory would not have issues, but a set of interacting bounded agents trying to minimise their rewriting/maintenance effort will inevitably make decisions to preserve and propagate suboptimal structures in the codebase because the dependency tree of the structure in question is too large.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"my contention is that java \"standards\", by which I mean logical structures the changing of which would propagate to a lot of dependencies, tend to be shaped like interfaces.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"also that this leads to specific absurdities in trying to attach any single task to the larger semantics of a codebase.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"concrete examples will follow if it seems worth pursuing in depth; I have anecdotes and one-off examples.\n"}]}]}]}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"inconsistencies arise because portions of the dependency tree are to be considered opaque wrt to their "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"functionality"}]},{"type":"text","value":", even though they are transparent "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"structurally"}]},{"type":"text","value":". The distinction breaks down in situations where, for eg.:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Class A has methods x and y where x and y are redundant\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Class B, inheriting A, notices this, and overrides A.x to call A.y (i.e. B.A.x -\u003e B.A.y, and B.A.y = A.y)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A is later rewritten to omit A.y; to deprecate A.y, it now calls A.x (i.e A.y -\u003e A.x)\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"this means B.A.y -\u003e B.A.x\n"}]}]}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"the-package-idiom-of-software-also-has-this-problem-in-a-more-general-sense"},"children":[{"type":"text","value":"The \"package\" idiom of software also has this problem in a more general sense"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here there is a "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Dependency_hell#Problems"},"children":[{"type":"text","value":"much more robust body"}]},{"type":"text","value":" of examples. "},{"type":"element","tagName":"a","properties":{"href":"https://nixos.wiki/wiki/Nix_Ecosystem"},"children":[{"type":"text","value":"NixOS"}]},{"type":"text","value":" and the nix package manager were expressly written in order to address this specific set of issues.\n"}]}]},"filetags":{},"backlinks":[{"path":"/all_pages","title":"All Pages"},{"path":"/examples","title":"Potential Real-world examples of rule dynamics"}]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20250126205645-java_codebases_vs_llvm_a_study_in_modules_and_monorepos"]},"buildId":"2M9sssCZQEkAkbm06CBb5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>