<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Toricelli</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c5198630dc662cd9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c5198630dc662cd9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-00e108e884e8ba17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5e7e1e817aab6e29.js" defer=""></script><script src="/_next/static/chunks/929-fd697a5772151b77.js" defer=""></script><script src="/_next/static/chunks/329-4859dea2fee324e7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-36a5cddfb88d7ae3.js" defer=""></script><script src="/_next/static/2M9sssCZQEkAkbm06CBb5/_buildManifest.js" defer=""></script><script src="/_next/static/2M9sssCZQEkAkbm06CBb5/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>Toricelli</h1><p>A tool to turn a corpus into a feed.
</p><h1 id="motivation">Motivation</h1><p>I want an inbox of things to write, read about, and expand on that&#x27;s drawn from my existing corpus. I like feeds. This is an opportunity to do <a href="id:4493a512-c5ca-4a27-915d-c3c4de9869f0">programmable attention</a> !
</p><h1 id="metadata">metadata</h1><div class="example">- ctime
- mtime
- srs_score (what happened the last time this was in the feed?)
- atime (pagevews)
- time last linked
- number of times linked
- keywords
- publication_ready: never|no|draft|done
</div><h1 id="algorithm-pagerank-ish">algorithm: pagerank-ish</h1><p>What we want is a cost function:
</p><ul><li><p>given a list of nodes (with associated above metadata) and edges between them, compute a score for each node, then return the nodes with updated scores
</p><ul><li><p>optionally, figure out how to only re-compute scores for nodes that are affected by a change.
</p></li></ul></li></ul><h2 id="initial-guesses">initial guesses</h2><p>initial guess at a cost function:
</p><div class="example">srs_score = k * (now - supermemo_schedule mtime ctime srs_score) # this gets updated, presumably, after some change to the page
</div><p>treat srs<sub>score</sub> as the page weight for pagerank
</p><p>sid&#x27;s guess: put srs<sub>score</sub> as the damping factor
</p><h2 id="alternative-supermemo-as-the-outer-loop">alternative: supermemo as the &quot;outer loop&quot;</h2><ul><li><p>[bollu] Reasoning: we want an SRS-shaped output, spiritually - a queue sort of thing that updates as you interact with it.
</p><ul><li><p>[itihas] I find this convincing.
</p></li></ul></li></ul><h2 id="next-guess">next guess</h2><pre class="src-block"><code># srs_score q n EF I -&gt; n EF I
</code></pre><p>sid:
</p><pre class="src-block"><code>I = max(1, f(I,page_rank_score))
</code></pre><p>where
</p><ul><li><p>f(I) &lt;= I. super-memo gives us an upper bound on when we should see a page again. PageRank can make us see a page earlier than
</p></li></ul><p>2  supermemo wanted us to, because we&#x27;re trying to keep stuff in working memory that may not optimal for long-term retention, but useful
  for short-term task clustering.
</p><ul><li><p>[itihas] Not really trying to keep task-related stuff together so much as surface things I care about <em>in-context</em> more than I might care about it &quot;naively&quot;.
</p></li></ul><p>It&#x27;s meant to produce connections I haven&#x27;t necessarily made before (generate new knowledge). The &quot;forgetting curve&quot; emphasis in SRS literature treats knowledge as atomic in a way that doesn&#x27;t make sense to me.
</p><ul><li><p>if s1 &gt; s2, f(I, s1) &lt; f(I, s2). If page rank deems a page more important, then see it sooner.
</p></li></ul><h2 id="for-reference-supermemo-the-various-algorithms-what-theyre-tracking-and-how-theyre-trying-to-track-it">for reference: supermemo, the various algorithms, what they&#x27;re tracking and how they&#x27;re trying to track it</h2><pre class="src-block"><code># sm_2: q:user_score n:repetition_number EF:easiness_factor I:interval -&gt; n EF I
sm_2 q n EF I := 
    if q &gt;= 3:
        if n = 0:
            I = 1
        if n = 1:
            I = 6
        else:
            I = round(I * EF)
        n = n + 1
    else:
        n = 0
        I = 1
    calc_EF = EF + (0.1 - (5 - q) * (0.08 + (5-q) * 0.02))
    EF = min(calc_EF, 1.3)
</code></pre><p>From <a href="https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline">https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline</a> :
</p><blockquote><p>
The Algorithm: Outline
The following procedure can be used to determine the status of memory (DSR status) at any moment of time for a given history of repetitions. Once the DSR status is known, we can determine the next interval using criteria of choice, e.g. forgetting index, maximization of stability, long-term workload minimization, etc.
</p><p>estimate item difficulty D using the history repetitions for that item
determine startup stability S0 using the history of repetitions
for all repetition history records repeat the steps below
compute theoretical retrievability Rt using current stability estimate Sw and the interval Int
update Recall[] matrix using D, Sw[n-1], Rt with the grade-derived recall
compute recall-based retrievability Rr
compute grade-derived retrievability Rg
estimate weighted Rw from Rt, Rr, and Rg
compute Rw-based stability Sr
compute SInc-based Se (Se=Sw[n-1]*SInc[D,Sw[n-1],Rw])
compute interval derived stability Si
estimate weighted Sw from Sr, Se, and Si
compute the stability increase SInc on the basis of Sw change
update Sinc[] matrix using D, Sw, Rw with the new SInc value
compute new interval using Int:=Sw*SInc[D,Sw,Rw]
go back computing Rt step
</p></blockquote><p>Easiness factor shares some semantic features with <a href="id:fcd47c46-e1c3-4d95-9092-c3b0e564f7f5">frecency</a>.
</p><h1 id="in-emacs">in emacs:</h1><ul><li><p>org-roam-db-query funcall to list nodes in score order in a transient buffer
</p></li><li><p>org-roam-db-query funcall to provide dump of nodes as a list of objects for the library to read in some suitably agnostic format (default choice JSON)
</p></li></ul><h1 id="note-from-sid-write-the-api-wrangling-that-gets-it-to-work-in-gemini--ducky--copilot">note from sid: write the API wrangling that gets it to work in gemini / ducky / copilot!</h1><p>Did this! Claude got me started quite usefully, wrote the skeleton and a first guess of the code.
</p><h1 id="related">Related:</h1><ul><li><p><a href="id:34e0bd60-a683-4f36-ac55-1799f57da198">Reviewing As Thinking | HowToRemember.biz</a></p></li></ul><section><h2>Backlinks</h2><ul><li><a href="/20210712224100-spaced_repetition_memory_prompts_should_connect_and_relate_ideas">Spaced repetition memory prompts should connect and relate ideas</a></li><li><a href="/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them">Zettelkasten is about developing ideas, not collecting them</a></li><li><a href="/20240815103857-blogging_project">blogging project</a></li><li><a href="/20240908233908-api_first_or_algorithm">api first, or algorithm?</a></li><li><a href="/all_pages">All Pages</a></li><li><a href="/github_alraban_org_recoll_a_lightweight_emacs_org_mode_wrapper_for_the_recoll_full_text_search_engine">GitHub - alraban/org-recoll: A lightweight emacs org-mode wrapper for the recoll full-text search engine</a></li><li><a href="/index">Org-Notebook</a></li></ul></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Toricelli","hast":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A tool to turn a corpus into a feed.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"motivation"},"children":[{"type":"text","value":"Motivation"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I want an inbox of things to write, read about, and expand on that's drawn from my existing corpus. I like feeds. This is an opportunity to do "},{"type":"element","tagName":"a","properties":{"href":"id:4493a512-c5ca-4a27-915d-c3c4de9869f0"},"children":[{"type":"text","value":"programmable attention"}]},{"type":"text","value":" !\n"}]},{"type":"element","tagName":"h1","properties":{"id":"metadata"},"children":[{"type":"text","value":"metadata"}]},{"type":"element","tagName":"div","properties":{"className":["example"]},"children":[{"type":"text","value":"- ctime\n- mtime\n- srs_score (what happened the last time this was in the feed?)\n- atime (pagevews)\n- time last linked\n- number of times linked\n- keywords\n- publication_ready: never|no|draft|done\n"}]},{"type":"element","tagName":"h1","properties":{"id":"algorithm-pagerank-ish"},"children":[{"type":"text","value":"algorithm: pagerank-ish"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What we want is a cost function:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"given a list of nodes (with associated above metadata) and edges between them, compute a score for each node, then return the nodes with updated scores\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"optionally, figure out how to only re-compute scores for nodes that are affected by a change.\n"}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"initial-guesses"},"children":[{"type":"text","value":"initial guesses"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"initial guess at a cost function:\n"}]},{"type":"element","tagName":"div","properties":{"className":["example"]},"children":[{"type":"text","value":"srs_score = k * (now - supermemo_schedule mtime ctime srs_score) # this gets updated, presumably, after some change to the page\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"treat srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" as the page weight for pagerank\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sid's guess: put srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" as the damping factor\n"}]},{"type":"element","tagName":"h2","properties":{"id":"alternative-supermemo-as-the-outer-loop"},"children":[{"type":"text","value":"alternative: supermemo as the \"outer loop\""}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[bollu] Reasoning: we want an SRS-shaped output, spiritually - a queue sort of thing that updates as you interact with it.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[itihas] I find this convincing.\n"}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"next-guess"},"children":[{"type":"text","value":"next guess"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# srs_score q n EF I -\u003e n EF I\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sid:\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"I = max(1, f(I,page_rank_score))\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"where\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"f(I) \u003c= I. super-memo gives us an upper bound on when we should see a page again. PageRank can make us see a page earlier than\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2  supermemo wanted us to, because we're trying to keep stuff in working memory that may not optimal for long-term retention, but useful\n  for short-term task clustering.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[itihas] Not really trying to keep task-related stuff together so much as surface things I care about "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"in-context"}]},{"type":"text","value":" more than I might care about it \"naively\".\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's meant to produce connections I haven't necessarily made before (generate new knowledge). The \"forgetting curve\" emphasis in SRS literature treats knowledge as atomic in a way that doesn't make sense to me.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"if s1 \u003e s2, f(I, s1) \u003c f(I, s2). If page rank deems a page more important, then see it sooner.\n"}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"for-reference-supermemo-the-various-algorithms-what-theyre-tracking-and-how-theyre-trying-to-track-it"},"children":[{"type":"text","value":"for reference: supermemo, the various algorithms, what they're tracking and how they're trying to track it"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# sm_2: q:user_score n:repetition_number EF:easiness_factor I:interval -\u003e n EF I\nsm_2 q n EF I := \n    if q \u003e= 3:\n        if n = 0:\n            I = 1\n        if n = 1:\n            I = 6\n        else:\n            I = round(I * EF)\n        n = n + 1\n    else:\n        n = 0\n        I = 1\n    calc_EF = EF + (0.1 - (5 - q) * (0.08 + (5-q) * 0.02))\n    EF = min(calc_EF, 1.3)\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"From "},{"type":"element","tagName":"a","properties":{"href":"https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline"},"children":[{"type":"text","value":"https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline"}]},{"type":"text","value":" :\n"}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\nThe Algorithm: Outline\nThe following procedure can be used to determine the status of memory (DSR status) at any moment of time for a given history of repetitions. Once the DSR status is known, we can determine the next interval using criteria of choice, e.g. forgetting index, maximization of stability, long-term workload minimization, etc.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"estimate item difficulty D using the history repetitions for that item\ndetermine startup stability S0 using the history of repetitions\nfor all repetition history records repeat the steps below\ncompute theoretical retrievability Rt using current stability estimate Sw and the interval Int\nupdate Recall[] matrix using D, Sw[n-1], Rt with the grade-derived recall\ncompute recall-based retrievability Rr\ncompute grade-derived retrievability Rg\nestimate weighted Rw from Rt, Rr, and Rg\ncompute Rw-based stability Sr\ncompute SInc-based Se (Se=Sw[n-1]*SInc[D,Sw[n-1],Rw])\ncompute interval derived stability Si\nestimate weighted Sw from Sr, Se, and Si\ncompute the stability increase SInc on the basis of Sw change\nupdate Sinc[] matrix using D, Sw, Rw with the new SInc value\ncompute new interval using Int:=Sw*SInc[D,Sw,Rw]\ngo back computing Rt step\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Easiness factor shares some semantic features with "},{"type":"element","tagName":"a","properties":{"href":"id:fcd47c46-e1c3-4d95-9092-c3b0e564f7f5"},"children":[{"type":"text","value":"frecency"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"h1","properties":{"id":"in-emacs"},"children":[{"type":"text","value":"in emacs:"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"org-roam-db-query funcall to list nodes in score order in a transient buffer\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"org-roam-db-query funcall to provide dump of nodes as a list of objects for the library to read in some suitably agnostic format (default choice JSON)\n"}]}]}]},{"type":"element","tagName":"h1","properties":{"id":"note-from-sid-write-the-api-wrangling-that-gets-it-to-work-in-gemini--ducky--copilot"},"children":[{"type":"text","value":"note from sid: write the API wrangling that gets it to work in gemini / ducky / copilot!"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Did this! Claude got me started quite usefully, wrote the skeleton and a first guess of the code.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"related"},"children":[{"type":"text","value":"Related:"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"id:34e0bd60-a683-4f36-ac55-1799f57da198"},"children":[{"type":"text","value":"Reviewing As Thinking | HowToRemember.biz"}]}]}]}]}]},"filetags":{},"backlinks":[{"path":"/20210712224100-spaced_repetition_memory_prompts_should_connect_and_relate_ideas","title":"Spaced repetition memory prompts should connect and relate ideas"},{"path":"/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them","title":"Zettelkasten is about developing ideas, not collecting them"},{"path":"/20240815103857-blogging_project","title":"blogging project"},{"path":"/20240908233908-api_first_or_algorithm","title":"api first, or algorithm?"},{"path":"/all_pages","title":"All Pages"},{"path":"/github_alraban_org_recoll_a_lightweight_emacs_org_mode_wrapper_for_the_recoll_full_text_search_engine","title":"GitHub - alraban/org-recoll: A lightweight emacs org-mode wrapper for the recoll full-text search engine"},{"path":"/index","title":"Org-Notebook"}]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20240905120229-toricelli"]},"buildId":"2M9sssCZQEkAkbm06CBb5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>