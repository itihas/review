<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Toricelli</title><meta name="next-head-count" content="3"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/e030354651ddf935.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e030354651ddf935.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-00e108e884e8ba17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-195757f9fcff239e.js" defer=""></script><script src="/_next/static/chunks/929-fd697a5772151b77.js" defer=""></script><script src="/_next/static/chunks/329-4859dea2fee324e7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-36a5cddfb88d7ae3.js" defer=""></script><script src="/_next/static/I5zLvMqCtJIjMWs8Nnszm/_buildManifest.js" defer=""></script><script src="/_next/static/I5zLvMqCtJIjMWs8Nnszm/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>Toricelli</h1><section><h5>Tags</h5><ul>:draft:</ul></section><dl><dt>url</dt><dd><a href="https://github.com/itihas/toricelli">https://github.com/itihas/toricelli</a></dd></dl><p>A tool to turn a corpus into a feed.
</p><h1 id="why-toricelli">Why toricelli?</h1><p>At several points in recent history, Tumblr users have felt the need to create a howto for effectively using tumblr. Universal among these guides is the recommendation to switch your feed to chronological ordering.
Why does this work? Why does it outperform Tumblr&#x27;s best guess at what users want to see? One good answer is that the semantics of a chronological feed are legible to the user. A lot of power comes from knowing why one post follows another - including the ability to curate what you see by messing with who you follow and what content you block. It removes the algorithm as a confounding factor. I think the variable reward circuit in the human learning machine also stabilizes, and stops firing, once it has actually learned a pattern. Hypothesis: gambling is pareidolia.
</p><p>For some time I&#x27;ve been grappling with the problem of returning to things in my giant-ass notebook. I used to bookmark into here; I also used to catch stray thoughts from inside pomodoros into here; talk through sensitive mental problems with myself in here; draft all my academic output, and most of my creative writing output, in here. I&#x27;ve used it for project management, one-off task tracking, collating records of important email threads, running quantified self experiments...
</p><p>And gradually, this tapered off. I&#x27;ve spent a long time wondering why, but awhile back I figured it out. Once the notebook got too big, all my guesses at how it was organized became too wrong to be useful. I couldn&#x27;t navigate it anymore.
</p><p>I think this is a fairly challenging problem. An exobrain isn&#x27;t meant to be a dead thing. It&#x27;s meant to <em>work with</em> the brain. The breadth of the interface needed to make such a thing useful means that it needs to be, in some nascent way, alive in its own right. As they say about hairstyles, it needs movement.
</p><p>I spent some years meditating on this; my best lead for a long while felt like <a href="/yow_2014_edward_kmett_stop_treading_water_learning_to_learn_yow_youtube">YOW! 2014 Edward Kmett - Stop Treading Water: Learning to Learn #YOW - YouTube</a>, where the presenter talks about how his Github projects organically arrange his work into a spaced-repetition-style recall exercise. There&#x27;s something about how humans interface with each other about high-density subjects that rhymes with how I wanted the interface with my notebook to work. But spaced repetition wasn&#x27;t quite right - an SRS deck grows, but doesn&#x27;t really have a rich theory of change. Is that right? It&#x27;s not quite right. Say rather that it expands, but doesn&#x27;t quite <a href="https://notes.andymatuschak.org/Knowledge_work_should_accrete">accrete</a>. There&#x27;s something disconcerting about how an uncurated SRS deck flings you from  subject to subject. It feels like it burns through a line of credit that my mind is extending it - and yeah, upon examination, that is what it&#x27;s doing! I&#x27;ts burning through my capacity and willingness to switch context, but it often isn&#x27;t rewarding me with anything for doing it. An SRS card is a recall task, and recall tasks are often harder than they are enjoyable - especially early in the process. The hedonics of an SRS deck are off. This isn&#x27;t a good <a href="/20250403213714-motivation_curve">motivation curve</a>.
</p><p>Let&#x27;s try to make it up a little bit. I want <em>context</em> to my SRS deck. The key is to notice that a deck is a form of <a href="/programmable_attention">programmable attention</a>. In fact, it&#x27;s the classic example - a feed. It augments and mediates your attention via an algorithm.
</p><p>I realized what I needed was something like spaced repetition in two ways:
</p><ul><li><p>it takes in a list of items I want to look at and outputs an subset of them to look at now. In other words, a paginated feed.
</p></li><li><p>it lets me fuzzy-defer items - effectively, it lets me say, show me this again soon, or not so soon, or quite late. In other words, a todo list.
</p></li></ul><p>I wanted a few other things, which needed to live <em>inside</em> the feed idiom:
</p><ul><li><p>The structure of my notes themselves needed to shape what was happening somehow. Their relations and correlations ought to inform what I&#x27;m looking at in the way web browsing hsapes what I look at.
</p></li><li><p>What I began with in the first place - my notes needed to <em>grow</em>. I wanted to develop things I found in here over time; link, expand, deepen; solve problems, correct misconceptions, learn and document nuance. Recall is all well and good, but I care more about doing and logging work I can return to. I memorise everything worth memroising near-automatically, so my real challenge was always going to be finding or making things I felt were worth memorising.
</p></li></ul><p>When I look at a note again, I usually want to <em>change</em> it, <em>read</em> it, or <em>browse</em> it. Either it&#x27;s done, and I get to remember some beautiful work I&#x27;ve done or thing I&#x27;ve found - ideally, for an annotated bookmark, both; or it&#x27;s not done, or stale, or missing connections to things, and I want to change the note; or, whatever its doneness, I care more right now that it links to or reminds me of something that&#x27;s caught my attention. What I want is a collection of entry points into my notes with the right <em>movement</em> to flow with these workflows.
</p><p>SRS ideas cover reading and changing, but they don&#x27;t really cover browsing. For this, I decided to run PageRank on the resulting scores.
</p><p>A few months of usage in, I realized I was very very bored with how repetitious the results were. While my goal of surfacing unexpected 2nd-degree-and-up connections was well served, clusters of related nodes tended to show up near each other, and standalones were completely shafted. I couldn&#x27;t figure out a way to mitigate this - it&#x27;s too deeply part of the <em>point</em> of PageRank. The algorithm assumes that all the entropy comes from the keyword search - the sheer number of possible results. It needs to extract all the order it can get out of the links. I I realized that I needed almost the inverse behaviour; to <em>invert</em> the standard PageRank score modifications, so that nodes that were too closely related didn&#x27;t all show up - in fact, I needed them to compete, and to have a clear winner that changed often within a cluster. It is nighttime and I am still mulling over the nicest way to represent this.
</p><p>One thing this problem does is clarify my goals for the feed. At present, I get to maybe two real entry points (deduplicating nodes that are too closely related) in a day. But if it&#x27;s a good day, that number jumps to more like twenty. On days where I am carrying over context from an already open thread, or where I have some other heavy work going on, it drops to zero or one. All of this is fine. The real goal is tastiness, enough tastiness to make the harder days still intuitively worthwhile. I want the opportunities inside the Toricelli feed to feel <em>good</em>, good enough to make me want the one.
</p><p>So what I want is for the top ten results to have at least three things that are interesting enough to suck me in, the way any feed worth its salt does.
</p><h1 id="background---srs-algorithms">background - SRS algorithms</h1><p>Consider a value R, the probability of recall - i.e. whether you pass the test a card gives you. SRS axioms are as follows:
</p><ul><li><p><span class="math math-inline">R</span> for a given piece of information can be modeled by a decay function over time, unless acted upon by a recall test. This decay function is called the <a href="/20250211162720-forgetting_curve">forgetting curve</a>.
</p></li><li><p>If you pass a recall test at time <span class="math math-inline">t</span>:
</p><ul><li><p><span class="math math-inline">R</span> jumps to 1.
</p></li><li><p><span class="math math-inline">R</span> from <span class="math math-inline">t</span> onwards decays more slowly.
</p></li></ul></li><li><p>If you fail a recall test at time <span class="math math-inline">t</span>:
</p><ul><li><p><span class="math math-inline">R</span> still jumps, but to some value <span class="math math-inline">R_{reminded} &lt; 1</span>. (The test will remind you of the card.)
</p></li><li><p><span class="math math-inline">R</span>&#x27;s rate of decay reverts to <span class="math math-inline">k_0</span>.
</p></li></ul></li></ul><p>This is a control problem. Treat each test as costing some amount <span class="math math-inline">c</span>. You want to maximise the value of <span class="math math-inline">R</span> over time, for which your primary tool is running tests; and minimise the value of <span class="math math-inline">c</span> over time, for which your primary tool is making <span class="math math-inline">R</span> decay more slowly - that is, by maximising the chance that the user <em>passes</em> tests.You could say you want <span class="math math-inline">tests_{passed}/ tests_{total}</span> to converge to some nonzero value as fast as possible. (is this right?)
</p><p>So, the algorithm needs to:
</p><ul><li><p>guess the shape of the forgetting curve <span class="math math-inline">d: R \to \text{Time}</span> based on all available data / metadata about a card, including its test history.
</p></li><li><p>decide when to run the next test (after interval <span class="math math-inline">n</span>).
</p></li><li><p>when the test is run, update both <span class="math math-inline">d</span> and <span class="math math-inline">n</span>.
</p></li></ul><p>SM-2 implements this as two recurrence relations:
</p><ul><li><p><span class="math math-inline">n_i = n_{i-1}\timesEF_{i - 1}</span>, where <span class="math math-inline">EF_i</span> is a value derived from test history and updated with every test.
</p></li><li><p>First two values were fixed: <span class="math math-inline">n_1 = 1, n_2  = 6</span></p></li><li><p><span class="math math-inline">EF_1 = 2.5</span></p></li><li><p><span class="math math-inline">EF_i = EF_{i-1} + (0.1 - (5 -q) \times (0.08 + (5 - q) \times 0.02))</span> where <span class="math math-inline">q</span> is a score between 1 and 5 for each card.
</p><ul><li><p>simplifies to <span class="math math-inline">EF_i = EF_{i-1} + 0.28q -0.02q^2</span>.
</p></li></ul></li><li><p><span class="math math-inline">EF</span> is effectively how the decay is parametrized. Note that for <span class="math math-inline">q=4</span>, it never changes. In that universe, <span class="math math-inline">n</span> increases by a constant factor of 2.5 each time.
</p></li><li><p>The forgetting curve is only modeled for where it&#x27;s tested. Many possible functions could fit.
</p></li></ul><p>FSRS implements this by explicitly guessing a decay function:
</p><ul><li><p>establish a threshold value for <span class="math math-inline">R</span> - call this <span class="math math-inline">R_{test}</span> - and run a test at timestamp <span class="math math-inline">t \test{s.t.} d(t) = R_{test}</span>.
</p></li><li><p>model the decay as exponential, i.e. <span class="math math-inline">d(t) = (1 + kt)^c</span>,  <span class="math math-inline">k</span> is derived from test history  and <span class="math math-inline">c</span> is constant.
</p></li><li><p>update <span class="math math-inline">k</span> after every test. 
</p></li></ul><p>Both of these approaches makes choices about modeling based on what empirical data they have available about the forgetting curve, and what parametrizations of it let them update after every test.
</p><p>They represent solution points in a parent problem of scheduling events that optimise for an outside behaviour that is somehow responsive to the event.
</p><h1 id="metadata">metadata</h1><ul><li><p>mtimes
</p></li><li><p>score (some value that captures or summarises what happened the last time this was in the feed)
</p></li><li><p>links
</p></li><li><p>coming soon:
</p><ul><li><p>keywords as links
</p></li><li><p>link weights (maybe even link properties? inferred from the surrounding link context, perhaps.)
</p></li><li><p>publication<sub>status</sub>: never|no|draft|garden | done
</p></li></ul></li></ul><h1 id="algorithm">algorithm</h1><ul><li><p>calculate a standalone score based on when an SRS algorithm would show a card: this will only be used for ranking.
</p></li><li><p>run pagerank on it to promote clusters.
</p></li></ul><h1 id="related">Related:</h1><ul><li><p><a href="id:34e0bd60-a683-4f36-ac55-1799f57da198">Reviewing As Thinking | HowToRemember.biz</a></p></li></ul><section><h2>Backlinks</h2><ul><li><a href="/20210712224100-spaced_repetition_memory_prompts_should_connect_and_relate_ideas">Spaced repetition memory prompts should connect and relate ideas</a></li><li><a href="/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them">Zettelkasten is about developing ideas, not collecting them</a></li><li><a href="/20240815103857-blogging_project">blogging project</a></li><li><a href="/20240908233908-api_first_or_algorithm">api first, or algorithm?</a></li><li><a href="/all_pages">All Pages</a></li><li><a href="/github_alraban_org_recoll_a_lightweight_emacs_org_mode_wrapper_for_the_recoll_full_text_search_engine">GitHub - alraban/org-recoll: A lightweight emacs org-mode wrapper for the recoll full-text search engine</a></li><li><a href="/index">Org-Notebook</a></li></ul></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Toricelli","hast":{"type":"root","children":[{"type":"element","tagName":"dl","properties":{},"children":[{"type":"element","tagName":"dt","properties":{},"children":[{"type":"text","value":"url"}]},{"type":"element","tagName":"dd","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/itihas/toricelli"},"children":[{"type":"text","value":"https://github.com/itihas/toricelli"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A tool to turn a corpus into a feed.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"why-toricelli"},"children":[{"type":"text","value":"Why toricelli?"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At several points in recent history, Tumblr users have felt the need to create a howto for effectively using tumblr. Universal among these guides is the recommendation to switch your feed to chronological ordering.\nWhy does this work? Why does it outperform Tumblr's best guess at what users want to see? One good answer is that the semantics of a chronological feed are legible to the user. A lot of power comes from knowing why one post follows another - including the ability to curate what you see by messing with who you follow and what content you block. It removes the algorithm as a confounding factor. I think the variable reward circuit in the human learning machine also stabilizes, and stops firing, once it has actually learned a pattern. Hypothesis: gambling is pareidolia.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For some time I've been grappling with the problem of returning to things in my giant-ass notebook. I used to bookmark into here; I also used to catch stray thoughts from inside pomodoros into here; talk through sensitive mental problems with myself in here; draft all my academic output, and most of my creative writing output, in here. I've used it for project management, one-off task tracking, collating records of important email threads, running quantified self experiments...\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"And gradually, this tapered off. I've spent a long time wondering why, but awhile back I figured it out. Once the notebook got too big, all my guesses at how it was organized became too wrong to be useful. I couldn't navigate it anymore.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I think this is a fairly challenging problem. An exobrain isn't meant to be a dead thing. It's meant to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"work with"}]},{"type":"text","value":" the brain. The breadth of the interface needed to make such a thing useful means that it needs to be, in some nascent way, alive in its own right. As they say about hairstyles, it needs movement.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I spent some years meditating on this; my best lead for a long while felt like "},{"type":"element","tagName":"a","properties":{"href":"/yow_2014_edward_kmett_stop_treading_water_learning_to_learn_yow_youtube"},"children":[{"type":"text","value":"YOW! 2014 Edward Kmett - Stop Treading Water: Learning to Learn #YOW - YouTube"}]},{"type":"text","value":", where the presenter talks about how his Github projects organically arrange his work into a spaced-repetition-style recall exercise. There's something about how humans interface with each other about high-density subjects that rhymes with how I wanted the interface with my notebook to work. But spaced repetition wasn't quite right - an SRS deck grows, but doesn't really have a rich theory of change. Is that right? It's not quite right. Say rather that it expands, but doesn't quite "},{"type":"element","tagName":"a","properties":{"href":"https://notes.andymatuschak.org/Knowledge_work_should_accrete"},"children":[{"type":"text","value":"accrete"}]},{"type":"text","value":". There's something disconcerting about how an uncurated SRS deck flings you from  subject to subject. It feels like it burns through a line of credit that my mind is extending it - and yeah, upon examination, that is what it's doing! I'ts burning through my capacity and willingness to switch context, but it often isn't rewarding me with anything for doing it. An SRS card is a recall task, and recall tasks are often harder than they are enjoyable - especially early in the process. The hedonics of an SRS deck are off. This isn't a good "},{"type":"element","tagName":"a","properties":{"href":"/20250403213714-motivation_curve"},"children":[{"type":"text","value":"motivation curve"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's try to make it up a little bit. I want "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"context"}]},{"type":"text","value":" to my SRS deck. The key is to notice that a deck is a form of "},{"type":"element","tagName":"a","properties":{"href":"/programmable_attention"},"children":[{"type":"text","value":"programmable attention"}]},{"type":"text","value":". In fact, it's the classic example - a feed. It augments and mediates your attention via an algorithm.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I realized what I needed was something like spaced repetition in two ways:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"it takes in a list of items I want to look at and outputs an subset of them to look at now. In other words, a paginated feed.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"it lets me fuzzy-defer items - effectively, it lets me say, show me this again soon, or not so soon, or quite late. In other words, a todo list.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I wanted a few other things, which needed to live "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"inside"}]},{"type":"text","value":" the feed idiom:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The structure of my notes themselves needed to shape what was happening somehow. Their relations and correlations ought to inform what I'm looking at in the way web browsing hsapes what I look at.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What I began with in the first place - my notes needed to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"grow"}]},{"type":"text","value":". I wanted to develop things I found in here over time; link, expand, deepen; solve problems, correct misconceptions, learn and document nuance. Recall is all well and good, but I care more about doing and logging work I can return to. I memorise everything worth memroising near-automatically, so my real challenge was always going to be finding or making things I felt were worth memorising.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When I look at a note again, I usually want to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"change"}]},{"type":"text","value":" it, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"read"}]},{"type":"text","value":" it, or "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"browse"}]},{"type":"text","value":" it. Either it's done, and I get to remember some beautiful work I've done or thing I've found - ideally, for an annotated bookmark, both; or it's not done, or stale, or missing connections to things, and I want to change the note; or, whatever its doneness, I care more right now that it links to or reminds me of something that's caught my attention. What I want is a collection of entry points into my notes with the right "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"movement"}]},{"type":"text","value":" to flow with these workflows.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SRS ideas cover reading and changing, but they don't really cover browsing. For this, I decided to run PageRank on the resulting scores.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A few months of usage in, I realized I was very very bored with how repetitious the results were. While my goal of surfacing unexpected 2nd-degree-and-up connections was well served, clusters of related nodes tended to show up near each other, and standalones were completely shafted. I couldn't figure out a way to mitigate this - it's too deeply part of the "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"point"}]},{"type":"text","value":" of PageRank. The algorithm assumes that all the entropy comes from the keyword search - the sheer number of possible results. It needs to extract all the order it can get out of the links. I I realized that I needed almost the inverse behaviour; to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invert"}]},{"type":"text","value":" the standard PageRank score modifications, so that nodes that were too closely related didn't all show up - in fact, I needed them to compete, and to have a clear winner that changed often within a cluster. It is nighttime and I am still mulling over the nicest way to represent this.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One thing this problem does is clarify my goals for the feed. At present, I get to maybe two real entry points (deduplicating nodes that are too closely related) in a day. But if it's a good day, that number jumps to more like twenty. On days where I am carrying over context from an already open thread, or where I have some other heavy work going on, it drops to zero or one. All of this is fine. The real goal is tastiness, enough tastiness to make the harder days still intuitively worthwhile. I want the opportunities inside the Toricelli feed to feel "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"good"}]},{"type":"text","value":", good enough to make me want the one.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So what I want is for the top ten results to have at least three things that are interesting enough to suck me in, the way any feed worth its salt does.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"background---srs-algorithms"},"children":[{"type":"text","value":"background - SRS algorithms"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Consider a value R, the probability of recall - i.e. whether you pass the test a card gives you. SRS axioms are as follows:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" for a given piece of information can be modeled by a decay function over time, unless acted upon by a recall test. This decay function is called the "},{"type":"element","tagName":"a","properties":{"href":"/20250211162720-forgetting_curve"},"children":[{"type":"text","value":"forgetting curve"}]},{"type":"text","value":".\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you pass a recall test at time "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"t"}]},{"type":"text","value":":\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" jumps to 1.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" from "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"t"}]},{"type":"text","value":" onwards decays more slowly.\n"}]}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If you fail a recall test at time "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"t"}]},{"type":"text","value":":\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" still jumps, but to some value "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R_{reminded} \u003c 1"}]},{"type":"text","value":". (The test will remind you of the card.)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":"'s rate of decay reverts to "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"k_0"}]},{"type":"text","value":".\n"}]}]}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is a control problem. Treat each test as costing some amount "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"c"}]},{"type":"text","value":". You want to maximise the value of "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" over time, for which your primary tool is running tests; and minimise the value of "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"c"}]},{"type":"text","value":" over time, for which your primary tool is making "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" decay more slowly - that is, by maximising the chance that the user "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"passes"}]},{"type":"text","value":" tests.You could say you want "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"tests_{passed}/ tests_{total}"}]},{"type":"text","value":" to converge to some nonzero value as fast as possible. (is this right?)\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So, the algorithm needs to:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"guess the shape of the forgetting curve "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"d: R \\to \\text{Time}"}]},{"type":"text","value":" based on all available data / metadata about a card, including its test history.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"decide when to run the next test (after interval "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"n"}]},{"type":"text","value":").\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"when the test is run, update both "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"d"}]},{"type":"text","value":" and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"n"}]},{"type":"text","value":".\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SM-2 implements this as two recurrence relations:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"n_i = n_{i-1}\\timesEF_{i - 1}"}]},{"type":"text","value":", where "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"EF_i"}]},{"type":"text","value":" is a value derived from test history and updated with every test.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First two values were fixed: "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"n_1 = 1, n_2  = 6"}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"EF_1 = 2.5"}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"EF_i = EF_{i-1} + (0.1 - (5 -q) \\times (0.08 + (5 - q) \\times 0.02))"}]},{"type":"text","value":" where "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"q"}]},{"type":"text","value":" is a score between 1 and 5 for each card.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"simplifies to "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"EF_i = EF_{i-1} + 0.28q -0.02q^2"}]},{"type":"text","value":".\n"}]}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"EF"}]},{"type":"text","value":" is effectively how the decay is parametrized. Note that for "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"q=4"}]},{"type":"text","value":", it never changes. In that universe, "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"n"}]},{"type":"text","value":" increases by a constant factor of 2.5 each time.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The forgetting curve is only modeled for where it's tested. Many possible functions could fit.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"FSRS implements this by explicitly guessing a decay function:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"establish a threshold value for "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" - call this "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"R_{test}"}]},{"type":"text","value":" - and run a test at timestamp "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"t \\test{s.t.} d(t) = R_{test}"}]},{"type":"text","value":".\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"model the decay as exponential, i.e. "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"d(t) = (1 + kt)^c"}]},{"type":"text","value":",  "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"k"}]},{"type":"text","value":" is derived from test history  and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"c"}]},{"type":"text","value":" is constant.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"update "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"k"}]},{"type":"text","value":" after every test. \n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Both of these approaches makes choices about modeling based on what empirical data they have available about the forgetting curve, and what parametrizations of it let them update after every test.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"They represent solution points in a parent problem of scheduling events that optimise for an outside behaviour that is somehow responsive to the event.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"metadata"},"children":[{"type":"text","value":"metadata"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"mtimes\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"score (some value that captures or summarises what happened the last time this was in the feed)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"links\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"coming soon:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"keywords as links\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"link weights (maybe even link properties? inferred from the surrounding link context, perhaps.)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"publication"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"status"}]},{"type":"text","value":": never|no|draft|garden | done\n"}]}]}]}]}]},{"type":"element","tagName":"h1","properties":{"id":"algorithm"},"children":[{"type":"text","value":"algorithm"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"calculate a standalone score based on when an SRS algorithm would show a card: this will only be used for ranking.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"run pagerank on it to promote clusters.\n"}]}]}]},{"type":"element","tagName":"h1","properties":{"id":"related"},"children":[{"type":"text","value":"Related:"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"id:34e0bd60-a683-4f36-ac55-1799f57da198"},"children":[{"type":"text","value":"Reviewing As Thinking | HowToRemember.biz"}]}]}]}]}]},"filetags":":draft:","backlinks":[{"path":"/20210712224100-spaced_repetition_memory_prompts_should_connect_and_relate_ideas","title":"Spaced repetition memory prompts should connect and relate ideas"},{"path":"/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them","title":"Zettelkasten is about developing ideas, not collecting them"},{"path":"/20240815103857-blogging_project","title":"blogging project"},{"path":"/20240908233908-api_first_or_algorithm","title":"api first, or algorithm?"},{"path":"/all_pages","title":"All Pages"},{"path":"/github_alraban_org_recoll_a_lightweight_emacs_org_mode_wrapper_for_the_recoll_full_text_search_engine","title":"GitHub - alraban/org-recoll: A lightweight emacs org-mode wrapper for the recoll full-text search engine"},{"path":"/index","title":"Org-Notebook"}]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20240905120229-toricelli"]},"buildId":"I5zLvMqCtJIjMWs8Nnszm","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>