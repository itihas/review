<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Toricelli</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c5198630dc662cd9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c5198630dc662cd9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-00e108e884e8ba17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5e7e1e817aab6e29.js" defer=""></script><script src="/_next/static/chunks/929-fd697a5772151b77.js" defer=""></script><script src="/_next/static/chunks/329-4859dea2fee324e7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-36a5cddfb88d7ae3.js" defer=""></script><script src="/_next/static/joSgxY7zXjURtan0u3QT_/_buildManifest.js" defer=""></script><script src="/_next/static/joSgxY7zXjURtan0u3QT_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>Toricelli</h1><section><h5>Tags</h5><ul>:draft:</ul></section><dl><dt>url</dt><dd><a href="https://github.com/itihas/toricelli">https://github.com/itihas/toricelli</a></dd></dl><p>A tool to turn a corpus into a feed.
</p><h1 id="exposition">exposition</h1><p>At several points in recent history, Tumblr users have felt the need to create a howto for effectively using tumblr. Universal among these guides is the recommendation to switch your feed to chronological ordering.
Why does this work? Why does it outperform Tumblr&#x27;s best guess at what users want to see? One good answer is that the semantics of a chronological feed are legible to the user. A lot of power comes from knowing why one post follows another - including the ability to curate what you see by messing with who you follow and what content you block. It removes the algorithm as a confounding factor. I think the variable reward circuit in the human learning machine also stabilizes, and stops firing, once it has actually learned a pattern. Hypothesis: gambling is pareidolia.
</p><p>For some time I&#x27;ve been grappling with the problem of returning to things in my giant-ass notebook. I used to bookmark into here; I also used to catch stray thoughts from inside pomodoros into here; talk through sensitive mental problems with myself in here; draft all my academic output, and most of my creative writing output, in here. I&#x27;ve used it for project management, one-off task tracking, collating records of important email threads, running quantified self experiments...
</p><p>And gradually, this tapered off. I&#x27;ve spent a long time wondering why, but awhile back I figured it out. Once the notebook got too big, all my guesses at how it was organized became too wrong to be useful. I couldn&#x27;t navigate it anymore.
</p><p>I think this is a fairly challenging problem. An exobrain isn&#x27;t meant to be a dead thing. It&#x27;s meant to <em>work with</em> the brain. The breadth of the interface needed to make such a thing useful means that it needs to be, in some nascent way, alive in its own right. As they say about hairstyles, it needs movement.
</p><p>I spent some years meditating on this; my best lead for a long while felt like <a href="/yow_2014_edward_kmett_stop_treading_water_learning_to_learn_yow_youtube">YOW! 2014 Edward Kmett - Stop Treading Water: Learning to Learn #YOW - YouTube</a>, where the presenter talks about how his Github projects organically arrange his work into a spaced-repetition-style recall exercise. There&#x27;s something about how humans interface with each other about high-density subjects that rhymes with how I wanted the interface with my notebook to work. But spaced repetition wasn&#x27;t quite right - an SRS deck grows, but doesn&#x27;t really have a rich theory of change. Is that right? It&#x27;s not quite right. Say rather that it expands, but doesn&#x27;t quite <a href="https://notes.andymatuschak.org/Knowledge_work_should_accrete">accrete</a>. There&#x27;s something disconcerting about how an uncurated SRS deck flings you from  subject to subject. It feels like it burns through a line of credit that my mind is extending it - and yeah, upon examination, that is what it&#x27;s doing! I&#x27;ts burning through my capacity and willingness to switch context, but it often isn&#x27;t rewarding me with anything for doing it. An SRS card is a recall task, and recall tasks are often harder than they are enjoyable - especially early in the process. The hedonics of an SRS deck are off. This isn&#x27;t a good <a href="/20250403213714-motivation_curve">motivation curve</a>.
</p><p>Let&#x27;s try to make it up a little bit. I want <em>context</em> to my SRS deck. The key is to notice that a deck is a form of <a href="/programmable_attention">programmable attention</a>. In fact, it&#x27;s the classic example - a feed. It augments and mediates your attention via an algorithm.
</p><p>I realized what I needed was something like spaced repetition in two ways:
</p><ul><li><p>it takes in a list of items I want to look at and outputs an subset of them to look at now. In other words, a paginated feed.
</p></li><li><p>it lets me fuzzy-defer items - effectively, it lets me say, show me this again soon, or not so soon, or quite late. In other words, a todo list.
</p></li></ul><p>I wanted a few other things, which needed to live <em>inside</em> the feed idiom:
</p><ul><li><p>The structure of my notes themselves needed to shape what was happening somehow. Their relations and correlations ought to inform what I&#x27;m looking at in the way web browsing hsapes what I look at.
</p></li><li><p>What I began with in the first place - my notes needed to <em>grow</em>. I wanted to develop things I found in here over time; link, expand, deepen; solve problems, correct misconceptions, learn and document nuance. Recall is all well and good, but I care more about doing and logging work I can return to. I memorise everything worth memroising near-automatically, so my real challenge was always going to be finding or making things I felt were worth memorising.
</p></li></ul><p>When I look at a note again, I usually want to <em>change</em> it, <em>read</em> it, or <em>browse</em> it. Either it&#x27;s done, and I get to remember some beautiful work I&#x27;ve done or thing I&#x27;ve found - ideally, for an annotated bookmark, both; or it&#x27;s not done, or stale, or missing connections to things, and I want to change the note; or, whatever its doneness, I care more right now that it links to or reminds me of something that&#x27;s caught my attention. What I want is a collection of entry points into my notes with the right <em>movement</em> to flow with these workflows.
</p><p>SRS ideas cover reading and changing, but they don&#x27;t really cover browsing. For this, I decided to run PageRank on the resulting scores.
</p><p>A few months of usage in, I realized I was very very bored with how repetitious the results were. While my goal of surfacing unexpected 2nd-degree-and-up connections was well served, clusters of related nodes tended to show up near each other, and standalones were completely shafted. I couldn&#x27;t figure out a way to mitigate this - it&#x27;s too deeply part of the <em>point</em> of PageRank. The algorithm assumes that all the entropy comes from the keyword search - the sheer number of possible results. It needs to extract all the order it can get out of the links. I I realized that I needed almost the inverse behaviour; to <em>invert</em> the standard PageRank score modifications, so that nodes that were too closely related didn&#x27;t all show up - in fact, I needed them to compete, and to have a clear winner that changed often within a cluster. It is nighttime and I am still mulling over the nicest way to represent this.
</p><p>One thing this problem does is clarify my goals for the feed. At present, I get to maybe two real entry points (deduplicating nodes that are too closely related) in a day. But if it&#x27;s a good day, that number jumps to more like twenty. On days where I am carrying over context from an already open thread, or where I have some other heavy work going on, it drops to zero or one. All of this is fine. The real goal is tastiness, enough tastiness to make the harder days still intuitively worthwhile. I want the opportunities inside the Toricelli feed to feel <em>good</em>, good enough to make me want the one.
</p><p>So what I want is for the top ten results to have at least three things that are interesting enough to suck me in, the way any feed worth its salt does.
</p><h1 id="metadata">metadata</h1><ul><li><p>mtimes
</p></li><li><p>feed<sub>score</sub> (what happened the last time this was in the feed?)
</p></li><li><p>link count
</p></li><li><p>avg<sub>link</sub><sub>score</sub></p></li><li><p>coming soon:
</p><ul><li><p>keywords as links
</p></li><li><p>link weights (maybe even link properties? inferred from the surrounding link context, perhaps.)
</p></li><li><p>publication<sub>status</sub>: never|no|draft|garden | done
</p></li></ul></li></ul><h1 id="algorithm">algorithm</h1><ul><li><p>calculate standalone scores. these are just 1/srs<sub>interval</sub>.
</p></li><li><p>run pagerank on standalone scores.
</p></li></ul><h1 id="earlier-guesses">earlier guesses</h1><p>initial guess at a cost function:
</p><div class="example">srs_score = k * (now - supermemo_schedule mtime ctime srs_score) # this gets updated, presumably, after some change to the page
</div><p>treat srs<sub>score</sub> as the page weight for pagerank
</p><p>sid&#x27;s guess: put srs<sub>score</sub> as the damping factor
</p><h2 id="alternative-supermemo-as-the-outer-loop">alternative: supermemo as the &quot;outer loop&quot;</h2><ul><li><p>[bollu] Reasoning: we want an SRS-shaped output, spiritually - a queue sort of thing that updates as you interact with it.
</p><ul><li><p>[itihas] I find this convincing.
</p></li></ul></li></ul><h2 id="next-guess">next guess</h2><pre class="src-block"><code># srs_score q n EF I -&gt; n EF I
</code></pre><p>sid:
</p><pre class="src-block"><code>I = max(1, f(I,page_rank_score))
</code></pre><p>where
</p><ul><li><p>f(I) &lt;= I. super-memo gives us an upper bound on when we should see a page again. PageRank can make us see a page earlier than
</p></li></ul><p>2  supermemo wanted us to, because we&#x27;re trying to keep stuff in working memory that may not optimal for long-term retention, but useful
  for short-term task clustering.
</p><ul><li><p>[itihas] Not really trying to keep task-related stuff together so much as surface things I care about <em>in-context</em> more than I might care about it &quot;naively&quot;.
</p></li></ul><p>It&#x27;s meant to produce connections I haven&#x27;t necessarily made before (generate new knowledge). The &quot;forgetting curve&quot; emphasis in SRS literature treats knowledge as atomic in a way that doesn&#x27;t make sense to me.
</p><ul><li><p>if s1 &gt; s2, f(I, s1) &lt; f(I, s2). If page rank deems a page more important, then see it sooner.
</p></li></ul><h2 id="for-reference-supermemo-the-various-algorithms-what-theyre-tracking-and-how-theyre-trying-to-track-it">for reference: supermemo, the various algorithms, what they&#x27;re tracking and how they&#x27;re trying to track it</h2><pre class="src-block"><code># sm_2: q:user_score n:repetition_number EF:easiness_factor I:interval -&gt; n EF I
sm_2 q n EF I := 
    if q &gt;= 3:
        if n = 0:
            I = 1
        if n = 1:
            I = 6
        else:
            I = round(I * EF)
        n = n + 1
    else:
        n = 0
        I = 1
    calc_EF = EF + (0.1 - (5 - q) * (0.08 + (5-q) * 0.02))
    EF = min(calc_EF, 1.3)
</code></pre><p>From <a href="https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline">https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline</a> :
</p><blockquote><p>
The Algorithm: Outline
The following procedure can be used to determine the status of memory (DSR status) at any moment of time for a given history of repetitions. Once the DSR status is known, we can determine the next interval using criteria of choice, e.g. forgetting index, maximization of stability, long-term workload minimization, etc.
</p><p>estimate item difficulty D using the history repetitions for that item
determine startup stability S0 using the history of repetitions
for all repetition history records repeat the steps below
compute theoretical retrievability Rt using current stability estimate Sw and the interval Int
update Recall[] matrix using D, Sw[n-1], Rt with the grade-derived recall
compute recall-based retrievability Rr
compute grade-derived retrievability Rg
estimate weighted Rw from Rt, Rr, and Rg
compute Rw-based stability Sr
compute SInc-based Se (Se=Sw[n-1]*SInc[D,Sw[n-1],Rw])
compute interval derived stability Si
estimate weighted Sw from Sr, Se, and Si
compute the stability increase SInc on the basis of Sw change
update Sinc[] matrix using D, Sw, Rw with the new SInc value
compute new interval using Int:=Sw*SInc[D,Sw,Rw]
go back computing Rt step
</p></blockquote><p>Easiness factor shares some semantic features with <a href="/frecency_wikipedia">frecency</a>.
</p><h1 id="note-from-sid-write-the-api-wrangling-that-gets-it-to-work-in-gemini--ducky--copilot">note from sid: write the API wrangling that gets it to work in gemini / ducky / copilot!</h1><p>Did this! Claude got me started quite usefully, wrote the skeleton and a first guess of the code.
</p><h1 id="related">Related:</h1><ul><li><p><a href="id:34e0bd60-a683-4f36-ac55-1799f57da198">Reviewing As Thinking | HowToRemember.biz</a></p></li></ul><section><h2>Backlinks</h2><ul><li><a href="/20210712224100-spaced_repetition_memory_prompts_should_connect_and_relate_ideas">Spaced repetition memory prompts should connect and relate ideas</a></li><li><a href="/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them">Zettelkasten is about developing ideas, not collecting them</a></li><li><a href="/20240815103857-blogging_project">blogging project</a></li><li><a href="/20240908233908-api_first_or_algorithm">api first, or algorithm?</a></li><li><a href="/all_pages">All Pages</a></li><li><a href="/github_alraban_org_recoll_a_lightweight_emacs_org_mode_wrapper_for_the_recoll_full_text_search_engine">GitHub - alraban/org-recoll: A lightweight emacs org-mode wrapper for the recoll full-text search engine</a></li><li><a href="/index">Org-Notebook</a></li></ul></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Toricelli","hast":{"type":"root","children":[{"type":"element","tagName":"dl","properties":{},"children":[{"type":"element","tagName":"dt","properties":{},"children":[{"type":"text","value":"url"}]},{"type":"element","tagName":"dd","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/itihas/toricelli"},"children":[{"type":"text","value":"https://github.com/itihas/toricelli"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A tool to turn a corpus into a feed.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"exposition"},"children":[{"type":"text","value":"exposition"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At several points in recent history, Tumblr users have felt the need to create a howto for effectively using tumblr. Universal among these guides is the recommendation to switch your feed to chronological ordering.\nWhy does this work? Why does it outperform Tumblr's best guess at what users want to see? One good answer is that the semantics of a chronological feed are legible to the user. A lot of power comes from knowing why one post follows another - including the ability to curate what you see by messing with who you follow and what content you block. It removes the algorithm as a confounding factor. I think the variable reward circuit in the human learning machine also stabilizes, and stops firing, once it has actually learned a pattern. Hypothesis: gambling is pareidolia.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For some time I've been grappling with the problem of returning to things in my giant-ass notebook. I used to bookmark into here; I also used to catch stray thoughts from inside pomodoros into here; talk through sensitive mental problems with myself in here; draft all my academic output, and most of my creative writing output, in here. I've used it for project management, one-off task tracking, collating records of important email threads, running quantified self experiments...\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"And gradually, this tapered off. I've spent a long time wondering why, but awhile back I figured it out. Once the notebook got too big, all my guesses at how it was organized became too wrong to be useful. I couldn't navigate it anymore.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I think this is a fairly challenging problem. An exobrain isn't meant to be a dead thing. It's meant to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"work with"}]},{"type":"text","value":" the brain. The breadth of the interface needed to make such a thing useful means that it needs to be, in some nascent way, alive in its own right. As they say about hairstyles, it needs movement.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I spent some years meditating on this; my best lead for a long while felt like "},{"type":"element","tagName":"a","properties":{"href":"/yow_2014_edward_kmett_stop_treading_water_learning_to_learn_yow_youtube"},"children":[{"type":"text","value":"YOW! 2014 Edward Kmett - Stop Treading Water: Learning to Learn #YOW - YouTube"}]},{"type":"text","value":", where the presenter talks about how his Github projects organically arrange his work into a spaced-repetition-style recall exercise. There's something about how humans interface with each other about high-density subjects that rhymes with how I wanted the interface with my notebook to work. But spaced repetition wasn't quite right - an SRS deck grows, but doesn't really have a rich theory of change. Is that right? It's not quite right. Say rather that it expands, but doesn't quite "},{"type":"element","tagName":"a","properties":{"href":"https://notes.andymatuschak.org/Knowledge_work_should_accrete"},"children":[{"type":"text","value":"accrete"}]},{"type":"text","value":". There's something disconcerting about how an uncurated SRS deck flings you from  subject to subject. It feels like it burns through a line of credit that my mind is extending it - and yeah, upon examination, that is what it's doing! I'ts burning through my capacity and willingness to switch context, but it often isn't rewarding me with anything for doing it. An SRS card is a recall task, and recall tasks are often harder than they are enjoyable - especially early in the process. The hedonics of an SRS deck are off. This isn't a good "},{"type":"element","tagName":"a","properties":{"href":"/20250403213714-motivation_curve"},"children":[{"type":"text","value":"motivation curve"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's try to make it up a little bit. I want "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"context"}]},{"type":"text","value":" to my SRS deck. The key is to notice that a deck is a form of "},{"type":"element","tagName":"a","properties":{"href":"/programmable_attention"},"children":[{"type":"text","value":"programmable attention"}]},{"type":"text","value":". In fact, it's the classic example - a feed. It augments and mediates your attention via an algorithm.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I realized what I needed was something like spaced repetition in two ways:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"it takes in a list of items I want to look at and outputs an subset of them to look at now. In other words, a paginated feed.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"it lets me fuzzy-defer items - effectively, it lets me say, show me this again soon, or not so soon, or quite late. In other words, a todo list.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I wanted a few other things, which needed to live "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"inside"}]},{"type":"text","value":" the feed idiom:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The structure of my notes themselves needed to shape what was happening somehow. Their relations and correlations ought to inform what I'm looking at in the way web browsing hsapes what I look at.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What I began with in the first place - my notes needed to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"grow"}]},{"type":"text","value":". I wanted to develop things I found in here over time; link, expand, deepen; solve problems, correct misconceptions, learn and document nuance. Recall is all well and good, but I care more about doing and logging work I can return to. I memorise everything worth memroising near-automatically, so my real challenge was always going to be finding or making things I felt were worth memorising.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When I look at a note again, I usually want to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"change"}]},{"type":"text","value":" it, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"read"}]},{"type":"text","value":" it, or "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"browse"}]},{"type":"text","value":" it. Either it's done, and I get to remember some beautiful work I've done or thing I've found - ideally, for an annotated bookmark, both; or it's not done, or stale, or missing connections to things, and I want to change the note; or, whatever its doneness, I care more right now that it links to or reminds me of something that's caught my attention. What I want is a collection of entry points into my notes with the right "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"movement"}]},{"type":"text","value":" to flow with these workflows.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SRS ideas cover reading and changing, but they don't really cover browsing. For this, I decided to run PageRank on the resulting scores.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A few months of usage in, I realized I was very very bored with how repetitious the results were. While my goal of surfacing unexpected 2nd-degree-and-up connections was well served, clusters of related nodes tended to show up near each other, and standalones were completely shafted. I couldn't figure out a way to mitigate this - it's too deeply part of the "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"point"}]},{"type":"text","value":" of PageRank. The algorithm assumes that all the entropy comes from the keyword search - the sheer number of possible results. It needs to extract all the order it can get out of the links. I I realized that I needed almost the inverse behaviour; to "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"invert"}]},{"type":"text","value":" the standard PageRank score modifications, so that nodes that were too closely related didn't all show up - in fact, I needed them to compete, and to have a clear winner that changed often within a cluster. It is nighttime and I am still mulling over the nicest way to represent this.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One thing this problem does is clarify my goals for the feed. At present, I get to maybe two real entry points (deduplicating nodes that are too closely related) in a day. But if it's a good day, that number jumps to more like twenty. On days where I am carrying over context from an already open thread, or where I have some other heavy work going on, it drops to zero or one. All of this is fine. The real goal is tastiness, enough tastiness to make the harder days still intuitively worthwhile. I want the opportunities inside the Toricelli feed to feel "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"good"}]},{"type":"text","value":", good enough to make me want the one.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So what I want is for the top ten results to have at least three things that are interesting enough to suck me in, the way any feed worth its salt does.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"metadata"},"children":[{"type":"text","value":"metadata"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"mtimes\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"feed"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" (what happened the last time this was in the feed?)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"link count\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"avg"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"link"}]},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"coming soon:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"keywords as links\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"link weights (maybe even link properties? inferred from the surrounding link context, perhaps.)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"publication"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"status"}]},{"type":"text","value":": never|no|draft|garden | done\n"}]}]}]}]}]},{"type":"element","tagName":"h1","properties":{"id":"algorithm"},"children":[{"type":"text","value":"algorithm"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"calculate standalone scores. these are just 1/srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"interval"}]},{"type":"text","value":".\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"run pagerank on standalone scores.\n"}]}]}]},{"type":"element","tagName":"h1","properties":{"id":"earlier-guesses"},"children":[{"type":"text","value":"earlier guesses"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"initial guess at a cost function:\n"}]},{"type":"element","tagName":"div","properties":{"className":["example"]},"children":[{"type":"text","value":"srs_score = k * (now - supermemo_schedule mtime ctime srs_score) # this gets updated, presumably, after some change to the page\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"treat srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" as the page weight for pagerank\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sid's guess: put srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" as the damping factor\n"}]},{"type":"element","tagName":"h2","properties":{"id":"alternative-supermemo-as-the-outer-loop"},"children":[{"type":"text","value":"alternative: supermemo as the \"outer loop\""}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[bollu] Reasoning: we want an SRS-shaped output, spiritually - a queue sort of thing that updates as you interact with it.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[itihas] I find this convincing.\n"}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"next-guess"},"children":[{"type":"text","value":"next guess"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# srs_score q n EF I -\u003e n EF I\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sid:\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"I = max(1, f(I,page_rank_score))\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"where\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"f(I) \u003c= I. super-memo gives us an upper bound on when we should see a page again. PageRank can make us see a page earlier than\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2  supermemo wanted us to, because we're trying to keep stuff in working memory that may not optimal for long-term retention, but useful\n  for short-term task clustering.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[itihas] Not really trying to keep task-related stuff together so much as surface things I care about "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"in-context"}]},{"type":"text","value":" more than I might care about it \"naively\".\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's meant to produce connections I haven't necessarily made before (generate new knowledge). The \"forgetting curve\" emphasis in SRS literature treats knowledge as atomic in a way that doesn't make sense to me.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"if s1 \u003e s2, f(I, s1) \u003c f(I, s2). If page rank deems a page more important, then see it sooner.\n"}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"for-reference-supermemo-the-various-algorithms-what-theyre-tracking-and-how-theyre-trying-to-track-it"},"children":[{"type":"text","value":"for reference: supermemo, the various algorithms, what they're tracking and how they're trying to track it"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# sm_2: q:user_score n:repetition_number EF:easiness_factor I:interval -\u003e n EF I\nsm_2 q n EF I := \n    if q \u003e= 3:\n        if n = 0:\n            I = 1\n        if n = 1:\n            I = 6\n        else:\n            I = round(I * EF)\n        n = n + 1\n    else:\n        n = 0\n        I = 1\n    calc_EF = EF + (0.1 - (5 - q) * (0.08 + (5-q) * 0.02))\n    EF = min(calc_EF, 1.3)\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"From "},{"type":"element","tagName":"a","properties":{"href":"https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline"},"children":[{"type":"text","value":"https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline"}]},{"type":"text","value":" :\n"}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\nThe Algorithm: Outline\nThe following procedure can be used to determine the status of memory (DSR status) at any moment of time for a given history of repetitions. Once the DSR status is known, we can determine the next interval using criteria of choice, e.g. forgetting index, maximization of stability, long-term workload minimization, etc.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"estimate item difficulty D using the history repetitions for that item\ndetermine startup stability S0 using the history of repetitions\nfor all repetition history records repeat the steps below\ncompute theoretical retrievability Rt using current stability estimate Sw and the interval Int\nupdate Recall[] matrix using D, Sw[n-1], Rt with the grade-derived recall\ncompute recall-based retrievability Rr\ncompute grade-derived retrievability Rg\nestimate weighted Rw from Rt, Rr, and Rg\ncompute Rw-based stability Sr\ncompute SInc-based Se (Se=Sw[n-1]*SInc[D,Sw[n-1],Rw])\ncompute interval derived stability Si\nestimate weighted Sw from Sr, Se, and Si\ncompute the stability increase SInc on the basis of Sw change\nupdate Sinc[] matrix using D, Sw, Rw with the new SInc value\ncompute new interval using Int:=Sw*SInc[D,Sw,Rw]\ngo back computing Rt step\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Easiness factor shares some semantic features with "},{"type":"element","tagName":"a","properties":{"href":"/frecency_wikipedia"},"children":[{"type":"text","value":"frecency"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"h1","properties":{"id":"note-from-sid-write-the-api-wrangling-that-gets-it-to-work-in-gemini--ducky--copilot"},"children":[{"type":"text","value":"note from sid: write the API wrangling that gets it to work in gemini / ducky / copilot!"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Did this! Claude got me started quite usefully, wrote the skeleton and a first guess of the code.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"related"},"children":[{"type":"text","value":"Related:"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"id:34e0bd60-a683-4f36-ac55-1799f57da198"},"children":[{"type":"text","value":"Reviewing As Thinking | HowToRemember.biz"}]}]}]}]}]},"filetags":":draft:","backlinks":[{"path":"/20210712224100-spaced_repetition_memory_prompts_should_connect_and_relate_ideas","title":"Spaced repetition memory prompts should connect and relate ideas"},{"path":"/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them","title":"Zettelkasten is about developing ideas, not collecting them"},{"path":"/20240815103857-blogging_project","title":"blogging project"},{"path":"/20240908233908-api_first_or_algorithm","title":"api first, or algorithm?"},{"path":"/all_pages","title":"All Pages"},{"path":"/github_alraban_org_recoll_a_lightweight_emacs_org_mode_wrapper_for_the_recoll_full_text_search_engine","title":"GitHub - alraban/org-recoll: A lightweight emacs org-mode wrapper for the recoll full-text search engine"},{"path":"/index","title":"Org-Notebook"}]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20240905120229-toricelli"]},"buildId":"joSgxY7zXjURtan0u3QT_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>