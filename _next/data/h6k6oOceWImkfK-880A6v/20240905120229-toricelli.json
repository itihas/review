{"pageProps":{"title":"Toricelli","hast":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A tool to turn a corpus into a feed.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"motivation"},"children":[{"type":"text","value":"Motivation"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I want an inbox of things to write, read about, and expand on that's drawn from my existing corpus. I like feeds. This is an opportunity to do "},{"type":"element","tagName":"a","properties":{"href":"id:4493a512-c5ca-4a27-915d-c3c4de9869f0"},"children":[{"type":"text","value":"programmable attention"}]},{"type":"text","value":" !\n"}]},{"type":"element","tagName":"h1","properties":{"id":"metadata"},"children":[{"type":"text","value":"metadata"}]},{"type":"element","tagName":"div","properties":{"className":["example"]},"children":[{"type":"text","value":"- ctime\n- mtime\n- srs_score (what happened the last time this was in the feed?)\n- atime (pagevews)\n- time last linked\n- number of times linked\n- keywords\n- publication_ready: never|no|draft|done\n"}]},{"type":"element","tagName":"h1","properties":{"id":"algorithm-pagerank-ish"},"children":[{"type":"text","value":"algorithm: pagerank-ish"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What we want is a cost function:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"given a list of nodes (with associated above metadata) and edges between them, compute a score for each node, then return the nodes with updated scores\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"optionally, figure out how to only re-compute scores for nodes that are affected by a change.\n"}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"initial-guesses"},"children":[{"type":"text","value":"initial guesses"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"initial guess at a cost function:\n"}]},{"type":"element","tagName":"div","properties":{"className":["example"]},"children":[{"type":"text","value":"srs_score = k * (now - supermemo_schedule mtime ctime srs_score) # this gets updated, presumably, after some change to the page\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"treat srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" as the page weight for pagerank\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sid's guess: put srs"},{"type":"element","tagName":"sub","properties":{},"children":[{"type":"text","value":"score"}]},{"type":"text","value":" as the damping factor\n"}]},{"type":"element","tagName":"h2","properties":{"id":"alternative-supermemo-as-the-outer-loop"},"children":[{"type":"text","value":"alternative: supermemo as the \"outer loop\""}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[bollu] Reasoning: we want an SRS-shaped output, spiritually - a queue sort of thing that updates as you interact with it.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[itihas] I find this convincing.\n"}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"next-guess"},"children":[{"type":"text","value":"next guess"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# srs_score q n EF I -> n EF I\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sid:\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"I = max(1, f(I,page_rank_score))\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"where\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"f(I) <= I. super-memo gives us an upper bound on when we should see a page again. PageRank can make us see a page earlier than\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2  supermemo wanted us to, because we're trying to keep stuff in working memory that may not optimal for long-term retention, but useful\n  for short-term task clustering.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[itihas] Not really trying to keep task-related stuff together so much as surface things I care about "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"in-context"}]},{"type":"text","value":" more than I might care about it \"naively\".\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's meant to produce connections I haven't necessarily made before (generate new knowledge). The \"forgetting curve\" emphasis in SRS literature treats knowledge as atomic in a way that doesn't make sense to me.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"if s1 > s2, f(I, s1) < f(I, s2). If page rank deems a page more important, then see it sooner.\n"}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"for-reference-supermemo-the-various-algorithms-what-theyre-tracking-and-how-theyre-trying-to-track-it"},"children":[{"type":"text","value":"for reference: supermemo, the various algorithms, what they're tracking and how they're trying to track it"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# sm_2: q:user_score n:repetition_number EF:easiness_factor I:interval -> n EF I\nsm_2 q n EF I := \n    if q >= 3:\n        if n = 0:\n            I = 1\n        if n = 1:\n            I = 6\n        else:\n            I = round(I * EF)\n        n = n + 1\n    else:\n        n = 0\n        I = 1\n    calc_EF = EF + (0.1 - (5 - q) * (0.08 + (5-q) * 0.02))\n    EF = min(calc_EF, 1.3)\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"From "},{"type":"element","tagName":"a","properties":{"href":"https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline"},"children":[{"type":"text","value":"https://supermemo.guru/wiki/Algorithm_SM-17#The_Algorithm:_Outline"}]},{"type":"text","value":" :\n"}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\nThe Algorithm: Outline\nThe following procedure can be used to determine the status of memory (DSR status) at any moment of time for a given history of repetitions. Once the DSR status is known, we can determine the next interval using criteria of choice, e.g. forgetting index, maximization of stability, long-term workload minimization, etc.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"estimate item difficulty D using the history repetitions for that item\ndetermine startup stability S0 using the history of repetitions\nfor all repetition history records repeat the steps below\ncompute theoretical retrievability Rt using current stability estimate Sw and the interval Int\nupdate Recall[] matrix using D, Sw[n-1], Rt with the grade-derived recall\ncompute recall-based retrievability Rr\ncompute grade-derived retrievability Rg\nestimate weighted Rw from Rt, Rr, and Rg\ncompute Rw-based stability Sr\ncompute SInc-based Se (Se=Sw[n-1]*SInc[D,Sw[n-1],Rw])\ncompute interval derived stability Si\nestimate weighted Sw from Sr, Se, and Si\ncompute the stability increase SInc on the basis of Sw change\nupdate Sinc[] matrix using D, Sw, Rw with the new SInc value\ncompute new interval using Int:=Sw*SInc[D,Sw,Rw]\ngo back computing Rt step\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Easiness factor shares some semantic features with "},{"type":"element","tagName":"a","properties":{"href":"id:fcd47c46-e1c3-4d95-9092-c3b0e564f7f5"},"children":[{"type":"text","value":"frecency"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"h1","properties":{"id":"in-emacs"},"children":[{"type":"text","value":"in emacs:"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"org-roam-db-query funcall to list nodes in score order in a transient buffer\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"org-roam-db-query funcall to provide dump of nodes as a list of objects for the library to read in some suitably agnostic format (default choice JSON)\n"}]}]}]},{"type":"element","tagName":"h1","properties":{"id":"note-from-sid-write-the-api-wrangling-that-gets-it-to-work-in-gemini--ducky--copilot"},"children":[{"type":"text","value":"note from sid: write the API wrangling that gets it to work in gemini / ducky / copilot!"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Did this! Claude got me started quite usefully, wrote the skeleton and a first guess of the code.\n"}]},{"type":"element","tagName":"h1","properties":{"id":"related"},"children":[{"type":"text","value":"Related:"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"id:34e0bd60-a683-4f36-ac55-1799f57da198"},"children":[{"type":"text","value":"Reviewing As Thinking | HowToRemember.biz"}]}]}]}]}]},"filetags":{},"backlinks":[{"path":"/20210713120500-zettelkasten_is_about_developing_ideas_not_collecting_them","title":"Zettelkasten is about developing ideas, not collecting them"},{"path":"/20240815103857-blogging_project","title":"blogging project"},{"path":"/20240908233908-api_first_or_algorithm","title":"api first, or algorithm?"},{"path":"/index","title":"Org-Notebook"}]},"__N_SSG":true}