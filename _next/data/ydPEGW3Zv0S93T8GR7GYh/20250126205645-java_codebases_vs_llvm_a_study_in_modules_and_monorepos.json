{"pageProps":{"title":"Java codebases vs LLVM - a study in modules and monorepos","hast":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{"id":"java-codebases-vs-llvm---a-study-in-modules-and-monorepos"},"children":[{"type":"text","value":"Java codebases vs LLVM - a study in modules and monorepos"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Java language is best used, according to its own philosophy, to write code as self-contained, with lots of internal dependencies, and well-defined predetermined interfaces to other code. Several consequences arise in long-lived codebases as a result of this.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"interfaces fossilize; it quickly becomes verboten to change how classes relate to other classes, because the dependency structure becomes too convoluted to disentangle or diff.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I say "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"becomes"}]},{"type":"text","value":" because here the black box becomes hard to describe; what is actually happening is that a single agent with sufficiently large memory would not have issues, but a set of interacting bounded agents trying to minimise their rewriting/maintenance effort will inevitably make decisions to preserve and propagate suboptimal structures in the codebase because the dependency tree of the structure in question is too large.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"my contention is that java \"standards\", by which I mean logical structures the changing of which would propagate to a lot of dependencies, tend to be shaped like interfaces.\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"also that this leads to specific absurdities in trying to attach any single task to the larger semantics of a codebase.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"concrete examples will follow if it seems worth pursuing in depth; I have anecdotes and one-off examples.\n"}]}]}]}]}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"inconsistencies arise because portions of the dependency tree are to be considered opaque wrt to their "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"functionality"}]},{"type":"text","value":", even though they are transparent "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"structurally"}]},{"type":"text","value":". The distinction breaks down in situations where, for eg.:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Class A has methods x and y where x and y are redundant\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Class B, inheriting A, notices this, and overrides A.x to call A.y (i.e. B.A.x -> B.A.y, and B.A.y = A.y)\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A is later rewritten to omit A.y; to deprecate A.y, it now calls A.x (i.e A.y -> A.x)\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"this means B.A.y -> B.A.x\n"}]}]}]}]}]}]}]},{"type":"element","tagName":"h2","properties":{"id":"the-package-idiom-of-software-also-has-this-problem-in-a-more-general-sense"},"children":[{"type":"text","value":"The \"package\" idiom of software also has this problem in a more general sense"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here there is a "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Dependency_hell#Problems"},"children":[{"type":"text","value":"much more robust body"}]},{"type":"text","value":" of examples. "},{"type":"element","tagName":"a","properties":{"href":"https://nixos.wiki/wiki/Nix_Ecosystem"},"children":[{"type":"text","value":"NixOS"}]},{"type":"text","value":" and the nix package manager were expressly written in order to address this specific set of issues.\n"}]}]},"filetags":{},"backlinks":[{"path":"/all_pages","title":"All Pages"},{"path":"/examples","title":"Potential Real-world examples of rule dynamics"}]},"__N_SSG":true}