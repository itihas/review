{"pageProps":{"title":"codeblog/2012/2012-01-17-declarative-game-logic-afrp.md at master · leonidas/codeblog · GitHub","hast":{"type":"root","children":[{"type":"element","tagName":"dl","properties":{},"children":[{"type":"element","tagName":"dt","properties":{},"children":[{"type":"text","value":"url"}]},{"type":"element","tagName":"dd","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/leonidas/codeblog/blob/master/2012/2012-01-17-declarative-game-logic-afrp.md"},"children":[{"type":"text","value":"https://github.com/leonidas/codeblog/blob/master/2012/2012-01-17-declarative-game-logic-afrp.md"}]}]}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Purely Functional, Declarative Game Logic Using Reactive Programming\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In the previous article I introduced the Coroutine data type. In this second part I will show how coroutines can be used to implement a fixed time-step reactive programming library and use that library for modeling a simple game. The code examples will require a basic proficiency in reading Haskell code.\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Related: "},{"type":"element","tagName":"a","properties":{"href":"/20230727195750-functional_reactive_programming"},"children":[{"type":"text","value":"Functional Reactive Programming"}]}]}]},"filetags":{},"backlinks":[{"path":"/all_pages","title":"All Pages"}]},"__N_SSG":true}