<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>GNU make</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/3eaa1068495066ef.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3eaa1068495066ef.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/_next/static/chunks/main-cb4281779d2d79ab.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4c0dc0bab0cb5936.js" defer=""></script><script src="/_next/static/chunks/996-688166b5f820e4f8.js" defer=""></script><script src="/_next/static/chunks/733-216ebe5855141042.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-d642f8d10182b7a4.js" defer=""></script><script src="/_next/static/1cQ6jwPgnxv1qD5a1_g5c/_buildManifest.js" defer=""></script><script src="/_next/static/1cQ6jwPgnxv1qD5a1_g5c/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>GNU make</h1><section><h5>Tags</h5><ul>:cheatsheet:</ul></section><dl><dt>url</dt><dd><a href="https://bytes.usc.edu/cs104/wiki/makefile/">https://bytes.usc.edu/cs104/wiki/makefile/</a></dd></dl><blockquote><p>
Simple Example
</p><p>This simple Makefile compiles a hello.cpp program. It also includes a clean target that removes our executable in case we want to clean up the directory.
</p></blockquote><pre class="src-block"><code class="language-Makefile">   hello: hello.cpp
	g++ -g -Wall hello.cpp -o hello

clean:
	rm -f hello
</code></pre><blockquote><p>Multi-file Example
</p><p>It’s important to note a target can be named after after a file. This is most commonly used to:
</p><p>    Indicate that our target requires a file that must be compiled by another target.
    Only run our target when that dependency has changed to avoid doing extra work.
</p><p>Most of your homeworks will require you to compile multiple files, then link them all at once. To do this, we’ll use the -c compiler flag, which compiles without linking. Note that all the files we compile with -c have target names that correspond to the object files we’re expecting out.
</p><p>First, take a look at the imaginary file tree we’re basing this Makefile off of:
</p></blockquote><div class="example">program/
  main.cpp
  file1.cpp
  file1.h
  file2.cpp
</div><pre class="src-block"><code>all: program

program: main.cpp file1.o file2.o
	g++ -g -Wall main.cpp file1.o file2.o -o program

file1.o: file1.cpp file1.h
	g++ -g -Wall -c file1.cpp -o file1.o

file2.o: file2.cpp
	g++ -g -Wall -c file2.cpp -o file2.o

clean:
	rm -f *.o program

</code></pre><blockquote><p>    When you type make or make [target], the Make will look through your current directory for a Makefile. This file must be called makefile or Makefile.
    Make will then look for the corresponding target in the makefile. If you don’t provide a target, Make will just run the first target it finds.
    If the target is found, the target’s dependencies will be run as needed, then the target commands will be run.
    Oftentimes these commands start with g++, but they can be anything! You can run any command this way.
</p><p>The target dependency format looks like this. Note the tab indent before the commands; these are required!
</p></blockquote><pre class="src-block"><code class="language-Makefile">target1: dependency1 dependency2 ...
	command1
	command2
	...
</code></pre></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"GNU make","hast":{"type":"root","children":[{"type":"element","tagName":"dl","properties":{},"children":[{"type":"element","tagName":"dt","properties":{},"children":[{"type":"text","value":"url"}]},{"type":"element","tagName":"dd","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://bytes.usc.edu/cs104/wiki/makefile/"},"children":[{"type":"text","value":"https://bytes.usc.edu/cs104/wiki/makefile/"}]}]}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\nSimple Example\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This simple Makefile compiles a hello.cpp program. It also includes a clean target that removes our executable in case we want to clean up the directory.\n"}]}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-Makefile"]},"children":[{"type":"text","value":"   hello: hello.cpp\n\tg++ -g -Wall hello.cpp -o hello\n\nclean:\n\trm -f hello\n"}]}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Multi-file Example\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It’s important to note a target can be named after after a file. This is most commonly used to:\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"    Indicate that our target requires a file that must be compiled by another target.\n    Only run our target when that dependency has changed to avoid doing extra work.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Most of your homeworks will require you to compile multiple files, then link them all at once. To do this, we’ll use the -c compiler flag, which compiles without linking. Note that all the files we compile with -c have target names that correspond to the object files we’re expecting out.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First, take a look at the imaginary file tree we’re basing this Makefile off of:\n"}]}]},{"type":"element","tagName":"div","properties":{"className":["example"]},"children":[{"type":"text","value":"program/\n  main.cpp\n  file1.cpp\n  file1.h\n  file2.cpp\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"all: program\n\nprogram: main.cpp file1.o file2.o\n\tg++ -g -Wall main.cpp file1.o file2.o -o program\n\nfile1.o: file1.cpp file1.h\n\tg++ -g -Wall -c file1.cpp -o file1.o\n\nfile2.o: file2.cpp\n\tg++ -g -Wall -c file2.cpp -o file2.o\n\nclean:\n\trm -f *.o program\n\n"}]}]},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"    When you type make or make [target], the Make will look through your current directory for a Makefile. This file must be called makefile or Makefile.\n    Make will then look for the corresponding target in the makefile. If you don’t provide a target, Make will just run the first target it finds.\n    If the target is found, the target’s dependencies will be run as needed, then the target commands will be run.\n    Oftentimes these commands start with g++, but they can be anything! You can run any command this way.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The target dependency format looks like this. Note the tab indent before the commands; these are required!\n"}]}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-Makefile"]},"children":[{"type":"text","value":"target1: dependency1 dependency2 ...\n\tcommand1\n\tcommand2\n\t...\n"}]}]}]},"filetags":":cheatsheet:","backlinks":[]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20220210222100-gnu_make"]},"buildId":"1cQ6jwPgnxv1qD5a1_g5c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>