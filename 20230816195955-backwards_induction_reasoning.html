<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>backwards-induction reasoning</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c5198630dc662cd9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c5198630dc662cd9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-a85322f027b40e20.js" defer=""></script><script src="/_next/static/chunks/main-00e108e884e8ba17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5e7e1e817aab6e29.js" defer=""></script><script src="/_next/static/chunks/929-fd697a5772151b77.js" defer=""></script><script src="/_next/static/chunks/329-4859dea2fee324e7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-36a5cddfb88d7ae3.js" defer=""></script><script src="/_next/static/gozuaWB0mxG4TSZJqOmLO/_buildManifest.js" defer=""></script><script src="/_next/static/gozuaWB0mxG4TSZJqOmLO/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><h1>backwards-induction reasoning</h1><p>Integral part of the classic solution concepts for extensive-form games. Solved for two-player games; generalizes to n-player games in the same way the Nash equilibirum does. (I think?)
</p><p>Player A reasons backwards from a given outcome to see if it is reachable if, at each step backwards in the tree from that outcome, either
</p><ol><li><p>the parent node is under A&#x27;s control, or
</p></li><li><p>the parent node is under B&#x27;s control, and among the available choices of subtree for B at the parent node, the subtree represented by the current node represents the greatest reachable payoff for B.
</p></li></ol><p>The inductive reasoning thus considers the maximum reachable payoff at each node for the player controlling that node. This means that the set of A&#x27;s reachable outcomes is built exactly the same way as the set of B&#x27;s reachable outcomes, and that both player&#x27;s preferences among outcomes are used to build that set. The sets must wind up identical, and eveyr element in them represents a Nash equilibrium to the game.
</p><p>Also, because each subgame (each subtree) is solved in its own right, each of the equilibria at the root represents a <a href="id:49edf8c6-8d70-4bbc-bff4-c35762a25908">subgame-perfect equilibrium</a> for 2-player extensive-form games.
</p><p>This solution format works as long as one can inductively reason along the game-subgame relationship. <a title="Deconstruction of Infinite Extensive Games Using Coinduction" href="/lescannedeconstruction2009">Lescanne</a> takes leaf nodes in an non-finite tree as the bases for this inductive reasoning, thus giving us a way to characterise subgame-perfect equilibria in non-finite games.
</p><section><h2>Backlinks</h2><ul><li><a href="/aluralternatingtime2002">Alur, Rajeev and Henzinger, Thomas A. and Kupferman, Orna :: Alternating-Time Temporal Logic</a></li><li><a href="/index">Org-Notebook</a></li></ul></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"backwards-induction reasoning","hast":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Integral part of the classic solution concepts for extensive-form games. Solved for two-player games; generalizes to n-player games in the same way the Nash equilibirum does. (I think?)\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Player A reasons backwards from a given outcome to see if it is reachable if, at each step backwards in the tree from that outcome, either\n"}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"the parent node is under A's control, or\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"the parent node is under B's control, and among the available choices of subtree for B at the parent node, the subtree represented by the current node represents the greatest reachable payoff for B.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The inductive reasoning thus considers the maximum reachable payoff at each node for the player controlling that node. This means that the set of A's reachable outcomes is built exactly the same way as the set of B's reachable outcomes, and that both player's preferences among outcomes are used to build that set. The sets must wind up identical, and eveyr element in them represents a Nash equilibrium to the game.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Also, because each subgame (each subtree) is solved in its own right, each of the equilibria at the root represents a "},{"type":"element","tagName":"a","properties":{"href":"id:49edf8c6-8d70-4bbc-bff4-c35762a25908"},"children":[{"type":"text","value":"subgame-perfect equilibrium"}]},{"type":"text","value":" for 2-player extensive-form games.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This solution format works as long as one can inductively reason along the game-subgame relationship. "},{"type":"element","tagName":"a","properties":{"href":"/lescannedeconstruction2009","title":"Deconstruction of Infinite Extensive Games Using Coinduction"},"children":[{"type":"text","value":"Lescanne"}]},{"type":"text","value":" takes leaf nodes in an non-finite tree as the bases for this inductive reasoning, thus giving us a way to characterise subgame-perfect equilibria in non-finite games.\n"}]}]},"filetags":{},"backlinks":[{"path":"/aluralternatingtime2002","title":"Alur, Rajeev and Henzinger, Thomas A. and Kupferman, Orna :: Alternating-Time Temporal Logic"},{"path":"/index","title":"Org-Notebook"}]},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["20230816195955-backwards_induction_reasoning"]},"buildId":"gozuaWB0mxG4TSZJqOmLO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>